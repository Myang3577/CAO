{"ast":null,"code":"import { ActionType } from \"../actions/actions\"; // Defines the possible loading states\n\nexport let LoadingState;\n/**\n * Essentially a class definition. Defines what\n * fields are inside of the InitialState object.\n * In this case we have a variable called loading\n * of type LoadingState\n * There is another variable called movieSearchResult\n * that is of type object. {} means object type\n */\n\n(function (LoadingState) {\n  LoadingState[LoadingState[\"IDLE\"] = 0] = \"IDLE\";\n  LoadingState[LoadingState[\"LOADING\"] = 1] = \"LOADING\";\n  LoadingState[LoadingState[\"DONE\"] = 2] = \"DONE\";\n})(LoadingState || (LoadingState = {}));\n\n/**\n * Define a variable called initialState that is of type\n * InitialState. We then define the loading state to be\n * LoadingState.IDLE\n * We also define the movieSearchResult field to be an empty\n * object\n *\n * Note that InitialState is an arbitrary name. One reducer will have one set of\n * attributes defined by this type that it can modify. So we could have\n * userDataInitialState, movieListInitialState etc. And each one would define\n * the attributes that the respective reducer will be able to modify. BUT NOTE\n * THAT STATE IS ALWAYS GLOBAL. JUST BECAUSE REDUCER 1 CAN MODIFY X AND REDUCER\n * 2 CAN MODIFY Y DOES NOT MEAN THAT X AND Y ARE STORED SEPARATELY. THAT WOULD\n * DEFEAT THE POINT OF REDUX. Accessing them just becomes state.reducer1.x and\n * state.reducer2.y. All components are still allowed to read the global state,\n * but only if you are a reducer with the set attribute can you modify the\n * state.\n */\nconst initialState = {\n  loading: LoadingState.IDLE,\n  movieSearchResult: {}\n};\n/**\n * Define the other reducer. Takes 2 parameters state and action.\n * Every reducer must take these two things. The job of the\n * reducer is supposed to be used to set the state within the\n * storej.\n * action: Action): InitialState=>\n * The InitialState means the return type needs to be InitialState\n * It is also worth mentioning here that state = initialState\n *\n * @param state all of the states currently in the store. The default state it\n *              is set to is the variable initialState. This means that\n *              all of the states/attributes that exist have already been\n *              defined inside of initialState\n *\n * @param action the action we want to perform on the states in the store\n */\n\nexport const otherReducer = (state = initialState, action) => {\n  // Check the action type and choose the appropriate action. Within each action\n  // you set the states you want to set\n  switch (action.type) {\n    case ActionType.FETCH_BEGIN:\n      // Function calling because sometimes the cases get a bit long.\n      // In this case you are just passing on the state and action for the\n      // fetch reducer to do the state setting.\n      // Reducers always return back the state. The action of returning back the\n      // state is what actually sets the state within the store\n      return fetchBeginReducer(state, action);\n\n    case ActionType.FETCH_END:\n      // Another example of setting state. In this case it sets the\n      // movieSearchResult and the loading state. Note that states are\n      // overrided. That's what it means to set them\n      return { ...state,\n        movieSearchResult: action.payload,\n        loading: LoadingState.DONE\n      };\n\n    default:\n      return state;\n  }\n};\n\nconst fetchBeginReducer = (state, action) => {\n  // Reducers always return back the state. The action of returning back the\n  // state is what actually sets the state within the store\n  return { ...state,\n    loading: LoadingState.LOADING\n  };\n};\n\nexport default otherReducer;","map":{"version":3,"sources":["/home/eric/javascript-tmp-files/test-express/CAO/api/client/src/reducers/otherReducer.tsx"],"names":["ActionType","LoadingState","initialState","loading","IDLE","movieSearchResult","otherReducer","state","action","type","FETCH_BEGIN","fetchBeginReducer","FETCH_END","payload","DONE","LOADING"],"mappings":"AAAA,SAAiBA,UAAjB,QAAmC,oBAAnC,C,CAEA;;AACA,WAAYC,YAAZ;AAMA;;;;;;;;;WANYA,Y;AAAAA,EAAAA,Y,CAAAA,Y;AAAAA,EAAAA,Y,CAAAA,Y;AAAAA,EAAAA,Y,CAAAA,Y;GAAAA,Y,KAAAA,Y;;AAmBZ;;;;;;;;;;;;;;;;;;AAkBA,MAAMC,YAA0B,GAAG;AACjCC,EAAAA,OAAO,EAAEF,YAAY,CAACG,IADW;AAEjCC,EAAAA,iBAAiB,EAAE;AAFc,CAAnC;AAKA;;;;;;;;;;;;;;;;;AAgBA,OAAO,MAAMC,YAAY,GAAG,CAC1BC,KAAK,GAAGL,YADkB,EAE1BM,MAF0B,KAGT;AACjB;AACA;AACA,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKT,UAAU,CAACU,WAAhB;AACE;AACA;AACA;AACA;AACA;AACA,aAAOC,iBAAiB,CAACJ,KAAD,EAAQC,MAAR,CAAxB;;AACF,SAAKR,UAAU,CAACY,SAAhB;AACE;AACA;AACA;AACA,aAAO,EACL,GAAGL,KADE;AAELF,QAAAA,iBAAiB,EAAEG,MAAM,CAACK,OAFrB;AAGLV,QAAAA,OAAO,EAAEF,YAAY,CAACa;AAHjB,OAAP;;AAKF;AACE,aAAOP,KAAP;AAlBJ;AAoBD,CA1BM;;AA4BP,MAAMI,iBAAiB,GAAG,CAACJ,KAAD,EAAsBC,MAAtB,KAAyC;AACjE;AACA;AACA,SAAO,EACL,GAAGD,KADE;AAELJ,IAAAA,OAAO,EAAEF,YAAY,CAACc;AAFjB,GAAP;AAID,CAPD;;AASA,eAAeT,YAAf","sourcesContent":["import { Action, ActionType } from \"../actions/actions\";\n\n// Defines the possible loading states\nexport enum LoadingState {\n  IDLE,\n  LOADING,\n  DONE,\n}\n\n/**\n * Essentially a class definition. Defines what\n * fields are inside of the InitialState object.\n * In this case we have a variable called loading\n * of type LoadingState\n * There is another variable called movieSearchResult\n * that is of type object. {} means object type\n */\nexport interface InitialState {\n  loading: LoadingState;\n  movieSearchResult: {};\n}\n\n/**\n * Define a variable called initialState that is of type\n * InitialState. We then define the loading state to be\n * LoadingState.IDLE\n * We also define the movieSearchResult field to be an empty\n * object\n *\n * Note that InitialState is an arbitrary name. One reducer will have one set of\n * attributes defined by this type that it can modify. So we could have\n * userDataInitialState, movieListInitialState etc. And each one would define\n * the attributes that the respective reducer will be able to modify. BUT NOTE\n * THAT STATE IS ALWAYS GLOBAL. JUST BECAUSE REDUCER 1 CAN MODIFY X AND REDUCER\n * 2 CAN MODIFY Y DOES NOT MEAN THAT X AND Y ARE STORED SEPARATELY. THAT WOULD\n * DEFEAT THE POINT OF REDUX. Accessing them just becomes state.reducer1.x and\n * state.reducer2.y. All components are still allowed to read the global state,\n * but only if you are a reducer with the set attribute can you modify the\n * state.\n */\nconst initialState: InitialState = {\n  loading: LoadingState.IDLE,\n  movieSearchResult: {},\n};\n\n/**\n * Define the other reducer. Takes 2 parameters state and action.\n * Every reducer must take these two things. The job of the\n * reducer is supposed to be used to set the state within the\n * storej.\n * action: Action): InitialState=>\n * The InitialState means the return type needs to be InitialState\n * It is also worth mentioning here that state = initialState\n *\n * @param state all of the states currently in the store. The default state it\n *              is set to is the variable initialState. This means that\n *              all of the states/attributes that exist have already been\n *              defined inside of initialState\n *\n * @param action the action we want to perform on the states in the store\n */\nexport const otherReducer = (\n  state = initialState,\n  action: Action\n): InitialState => {\n  // Check the action type and choose the appropriate action. Within each action\n  // you set the states you want to set\n  switch (action.type) {\n    case ActionType.FETCH_BEGIN:\n      // Function calling because sometimes the cases get a bit long.\n      // In this case you are just passing on the state and action for the\n      // fetch reducer to do the state setting.\n      // Reducers always return back the state. The action of returning back the\n      // state is what actually sets the state within the store\n      return fetchBeginReducer(state, action);\n    case ActionType.FETCH_END:\n      // Another example of setting state. In this case it sets the\n      // movieSearchResult and the loading state. Note that states are\n      // overrided. That's what it means to set them\n      return {\n        ...state,\n        movieSearchResult: action.payload,\n        loading: LoadingState.DONE,\n      };\n    default:\n      return state;\n  }\n};\n\nconst fetchBeginReducer = (state: InitialState, action: Action) => {\n  // Reducers always return back the state. The action of returning back the\n  // state is what actually sets the state within the store\n  return {\n    ...state,\n    loading: LoadingState.LOADING,\n  };\n};\n\nexport default otherReducer;\n"]},"metadata":{},"sourceType":"module"}