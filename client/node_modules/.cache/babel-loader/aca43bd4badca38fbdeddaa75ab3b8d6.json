{"ast":null,"code":"// API key to query themoviedb database\nconst apiKey = \"5e38014a47f9412c29d0ca4667091633\";\n/**\n * Define your own enumerator called ActionType with two possible\n * values. Either FETCH_BEGIN or FETCH_END\n */\n\nexport let ActionType;\n/**\n * Define a \"class\" or object called Action that has two fields: type and\n * payload. We want a type because it allows us to know what objects we are\n * dealing with. We want payload because it is the object variable that is going\n * to hold our API response (which will be a JSONified object).\n *\n * At the end of the day an action is something that is brought to a reducer\n * which brings it to the store to update the state\n *\n * Actions MUST have a type. Everything else is up to you\n */\n\n(function (ActionType) {\n  ActionType[ActionType[\"FETCH_BEGIN\"] = 0] = \"FETCH_BEGIN\";\n  ActionType[ActionType[\"FETCH_END\"] = 1] = \"FETCH_END\";\n})(ActionType || (ActionType = {}));\n\n/**\n * An action creater that ONLY returns the specified Action. It's sole job is to\n * return actions. The return type of this particular action creator is Action\n * as seen by the (): Action\n *\n * This action creator does not take any parameters. So we are just setting some\n * default parameters. Ie. type is ActionType.FETCH_BEGIN and the payload is an\n * empty object\n */\nexport const fetchDataBegin = () => {\n  return {\n    type: ActionType.FETCH_BEGIN,\n    payload: {}\n  };\n};\n/**\n * An action creater that ONLY returns the specified Action. It's sole job is to\n * return actions. The return type of this particular action creator is Action\n * as seen by the (): Action\n *\n * This action creator does take parameters. Specifically it takes a parameter\n * called payload which is of type object. Then Within the function it just\n * return an action with the payload variable in the returned object set to be\n * the payload that was passed. See below why we would want to do this.\n *\n * @param payload\n */\n\nexport const fetchDataEnd = payload => {\n  return {\n    type: ActionType.FETCH_END,\n    payload: payload\n  };\n};\n/**\n * Conducts the API query. This is an async funciton partially handled by Thunk.\n * The first return returns a function. The second return actually returns the\n * result of the JSON\n *\n * The flow of this function is the following:\n * searchMovies is called with a query ->\n * we immediately update the state to show \"loading\" because we are beginning\n * the API query ->\n * We query the API ->\n * We either .json the response or show error\n * Finally we pass the json to fetchDataEnd which produces an action where the\n * payload is now filled with the json response ->\n * We then dispatch the Action to the reducer to hopefully update the states\n *\n * dispatch\n * @param query The name of the movie we want to search for\n */\n\nexport const searchMovies = query => {\n  return dispatch => {\n    dispatch(fetchDataBegin());\n    return fetch(\"https://api.themoviedb.org/3/search/movie?api_key=\" + apiKey + \"&language=en-US&query=\" + query + \"&include_adult=true\").then(response => response.json(), error => console.log(\"An error occurred.\", error)).then(json => dispatch(fetchDataEnd(json)));\n  };\n};","map":{"version":3,"sources":["/home/eric/javascript-tmp-files/test-express/CAO/src/actions/actions.tsx"],"names":["apiKey","ActionType","fetchDataBegin","type","FETCH_BEGIN","payload","fetchDataEnd","FETCH_END","searchMovies","query","dispatch","fetch","then","response","json","error","console","log"],"mappings":"AAEA;AACA,MAAMA,MAAM,GAAG,kCAAf;AAEA;;;;;AAIA,WAAYC,UAAZ;AAKA;;;;;;;;;;;;WALYA,U;AAAAA,EAAAA,U,CAAAA,U;AAAAA,EAAAA,U,CAAAA,U;GAAAA,U,KAAAA,U;;AAsBZ;;;;;;;;;AASA,OAAO,MAAMC,cAAc,GAAG,MAAc;AAC1C,SAAO;AACLC,IAAAA,IAAI,EAAEF,UAAU,CAACG,WADZ;AAELC,IAAAA,OAAO,EAAE;AAFJ,GAAP;AAID,CALM;AAOP;;;;;;;;;;;;;AAYA,OAAO,MAAMC,YAAY,GAAID,OAAD,IAAyB;AACnD,SAAO;AACLF,IAAAA,IAAI,EAAEF,UAAU,CAACM,SADZ;AAELF,IAAAA,OAAO,EAAEA;AAFJ,GAAP;AAID,CALM;AAOP;;;;;;;;;;;;;;;;;;;AAkBA,OAAO,MAAMG,YAAY,GAAIC,KAAD,IAAmB;AAC7C,SAAQC,QAAD,IAAwB;AAC7BA,IAAAA,QAAQ,CAACR,cAAc,EAAf,CAAR;AACA,WAAOS,KAAK,CACV,uDACEX,MADF,GAEE,wBAFF,GAGES,KAHF,GAIE,qBALQ,CAAL,CAOJG,IAPI,CAQFC,QAAD,IAAcA,QAAQ,CAACC,IAAT,EARX,EASFC,KAAD,IAAWC,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkCF,KAAlC,CATR,EAWJH,IAXI,CAWEE,IAAD,IAAUJ,QAAQ,CAACJ,YAAY,CAACQ,IAAD,CAAb,CAXnB,CAAP;AAYD,GAdD;AAeD,CAhBM","sourcesContent":["import { Dispatch } from \"redux\";\n\n// API key to query themoviedb database\nconst apiKey = \"5e38014a47f9412c29d0ca4667091633\";\n\n/**\n * Define your own enumerator called ActionType with two possible\n * values. Either FETCH_BEGIN or FETCH_END\n */\nexport enum ActionType {\n  FETCH_BEGIN,\n  FETCH_END,\n}\n\n/**\n * Define a \"class\" or object called Action that has two fields: type and\n * payload. We want a type because it allows us to know what objects we are\n * dealing with. We want payload because it is the object variable that is going\n * to hold our API response (which will be a JSONified object).\n *\n * At the end of the day an action is something that is brought to a reducer\n * which brings it to the store to update the state\n *\n * Actions MUST have a type. Everything else is up to you\n */\nexport interface Action {\n  type: ActionType;\n  // text: string;\n  payload: {};\n}\n\n/**\n * An action creater that ONLY returns the specified Action. It's sole job is to\n * return actions. The return type of this particular action creator is Action\n * as seen by the (): Action\n *\n * This action creator does not take any parameters. So we are just setting some\n * default parameters. Ie. type is ActionType.FETCH_BEGIN and the payload is an\n * empty object\n */\nexport const fetchDataBegin = (): Action => {\n  return {\n    type: ActionType.FETCH_BEGIN,\n    payload: {},\n  };\n};\n\n/**\n * An action creater that ONLY returns the specified Action. It's sole job is to\n * return actions. The return type of this particular action creator is Action\n * as seen by the (): Action\n *\n * This action creator does take parameters. Specifically it takes a parameter\n * called payload which is of type object. Then Within the function it just\n * return an action with the payload variable in the returned object set to be\n * the payload that was passed. See below why we would want to do this.\n *\n * @param payload\n */\nexport const fetchDataEnd = (payload: {}): Action => {\n  return {\n    type: ActionType.FETCH_END,\n    payload: payload,\n  };\n};\n\n/**\n * Conducts the API query. This is an async funciton partially handled by Thunk.\n * The first return returns a function. The second return actually returns the\n * result of the JSON\n *\n * The flow of this function is the following:\n * searchMovies is called with a query ->\n * we immediately update the state to show \"loading\" because we are beginning\n * the API query ->\n * We query the API ->\n * We either .json the response or show error\n * Finally we pass the json to fetchDataEnd which produces an action where the\n * payload is now filled with the json response ->\n * We then dispatch the Action to the reducer to hopefully update the states\n *\n * dispatch\n * @param query The name of the movie we want to search for\n */\nexport const searchMovies = (query: string) => {\n  return (dispatch: Dispatch) => {\n    dispatch(fetchDataBegin());\n    return fetch(\n      \"https://api.themoviedb.org/3/search/movie?api_key=\" +\n        apiKey +\n        \"&language=en-US&query=\" +\n        query +\n        \"&include_adult=true\"\n    )\n      .then(\n        (response) => response.json(),\n        (error) => console.log(\"An error occurred.\", error)\n      )\n      .then((json) => dispatch(fetchDataEnd(json)));\n  };\n};\n"]},"metadata":{},"sourceType":"module"}